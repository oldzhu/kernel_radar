# f8850bc3986562f79619: discussion notes (2026-02-12)

This note captures follow-up discussion items before applying any patch.

## What is TAPRIO?

- TAPRIO is the Time Aware Priority scheduler (qdisc) in Linux, implementing time-based gate control as defined by IEEE 802.1Qbv (Time-Aware Shaper).
- It is used in TSN (Time-Sensitive Networking) deployments to provide deterministic transmission windows per traffic class.

## Typical usage and examples

Common use cases:
- Industrial control and robotics (deterministic control frames).
- Automotive in-vehicle networks (mixed criticality traffic).
- Audio/Video Bridging (AVB) with strict timing constraints.

Example configuration (software mode):

```bash
tc qdisc replace dev eth0 root taprio \
  num_tc 3 map 0 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \
  queues 1@0 1@1 1@2 \
  base-time 0 \
  sched-entry S 0x1 1000000 \
  sched-entry S 0x2 1000000 \
  sched-entry S 0x4 1000000 \
  flags 0x0
```

- Each sched-entry interval is in nanoseconds.
- The example uses 1 ms per entry; values can be smaller but are usually in the microsecond or millisecond range in software mode.

More usage samples:

1) Align base-time to the next whole second:

```bash
BASE=$(date +%s)
BASE=$(( (BASE + 1) * 1000000000 ))
tc qdisc replace dev eth0 root taprio \
  num_tc 2 map 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \
  queues 1@0 1@1 \
  base-time $BASE \
  sched-entry S 0x1 500000 \
  sched-entry S 0x2 500000 \
  flags 0x0
```

2) TXTIME-assist mode (flags bit 0 = 0x1). Requires applications to use SO_TXTIME:

```bash
tc qdisc replace dev eth0 root taprio \
  num_tc 2 map 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \
  queues 1@0 1@1 \
  base-time 0 \
  sched-entry S 0x1 1000000 \
  sched-entry S 0x2 1000000 \
  flags 0x1
```

3) Full offload mode (flags bit 1 = 0x2). Only works if the NIC driver supports TAPRIO offload:

```bash
tc qdisc replace dev eth0 root taprio \
  num_tc 2 map 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \
  queues 1@0 1@1 \
  base-time 0 \
  sched-entry S 0x1 1000000 \
  sched-entry S 0x2 1000000 \
  flags 0x2
```

## Is a very small interval normal?

- In software mode, configuring a very small interval (sub-microsecond or a few hundred nanoseconds) is not typical.
- Extremely small intervals are mostly meaningful when the schedule is offloaded to hardware or when the platform has dedicated timing support.
- In general-purpose software scheduling, such tiny intervals are not realistically enforceable and can become a CPU DoS vector (timer catch-up storms).

## What is the use case for very small intervals?

- On hardware offload NICs, very small intervals can be used for fine-grained gate control aligned to PHY or MAC time domains.
- For pure software mode, realistic intervals are usually larger to account for system latency and timer resolution.

## Is advance_sched a generic timer? Who uses it?

- `advance_sched()` is the hrtimer callback internal to sch_taprio.c.
- It is not a generic kernel timer API. Other kernel components do not call it; it is scoped to the TAPRIO qdisc.
- It is used to advance TAPRIO schedule entries (gate transitions) and to trigger qdisc dequeueing in software mode.

## What is RCU in this context?

- RCU (Read-Copy-Update) is a synchronization mechanism that lets readers run without locks while updates happen in the background.
- Linux periodically needs CPUs to pass through quiescent states so RCU grace periods can complete.
- A tight timer catch-up loop can monopolize CPU time, delaying quiescent states, so RCU reports warnings like `rcu_preempt detected stalls`.

## What is advance_sched designed for?

- Purpose: advance the current gate list entry, update end times/budgets, and re-arm the hrtimer for the next gate transition.
- Common path: called only when TAPRIO is running in software mode (no full offload). It maintains time-based gating for traffic classes.

## Sample flow involving advance_sched

1) User configures TAPRIO schedule via `tc qdisc replace ... taprio`.
2) TAPRIO initializes schedule entries and starts the hrtimer.
3) `advance_sched()` fires at each entry boundary, updates the current entry, and re-arms the next boundary.
4) TAPRIO qdisc dequeues frames according to the gate mask and budgets for the current entry.

## Open discussion points

- Decide whether to prefer input validation (Option 1) or runtime catch-up protection (Option 2), or both.
- If Option 1, agree on the minimum software interval (e.g. 1 us) and how it should be documented to users.
- If Option 2, ensure schedule resync does not alter semantics for valid schedules while preventing timer storms.

## Why there may be no progress yet

- RCU stalls are often treated as a starvation symptom rather than a contained bug, so maintainers may wait for a clear fix.
- If the trigger is an extremely small interval that is unrealistic in software mode, it can be viewed as lower priority.
- Ownership is split between net/sched and TSN; fewer maintainers actively triage TAPRIO issues.
- Syzbot reports often move only after a candidate patch is posted and tested.

## Note on realism and review framing

- The current repro uses extremely small intervals that are unlikely in typical software-mode deployments.
- This still maps to a robustness/DoS-style input validation problem, which can be a reasonable framing for review even if the workload is pathological.
