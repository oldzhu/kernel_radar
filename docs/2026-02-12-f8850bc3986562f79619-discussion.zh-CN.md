# f8850bc3986562f79619: 讨论记录 (2026-02-12)

本文记录在应用补丁前的讨论要点，便于后续追踪。

## TAPRIO 是什么？

- TAPRIO 是 Linux 中的 Time Aware Priority 调度器（qdisc），实现了 IEEE 802.1Qbv 的时间感知门控机制。
- 主要用于 TSN（Time-Sensitive Networking），为不同流量类别提供确定性的发送窗口。

## 常见用途与示例

常见场景：
- 工业控制与机器人（控制报文的确定性时延）。
- 汽车车载网络（多关键度流量共存）。
- AVB 音视频（严格时间约束）。

示例配置（软件模式）：

```bash
tc qdisc replace dev eth0 root taprio \
  num_tc 3 map 0 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \
  queues 1@0 1@1 1@2 \
  base-time 0 \
  sched-entry S 0x1 1000000 \
  sched-entry S 0x2 1000000 \
  sched-entry S 0x4 1000000 \
  flags 0x0
```

- `sched-entry` 的 interval 单位是纳秒。
- 示例用的是 1 ms/entry；软件模式下常见的是微秒或毫秒级。

更多示例：

1) base-time 对齐到下一个整秒：

```bash
BASE=$(date +%s)
BASE=$(( (BASE + 1) * 1000000000 ))
tc qdisc replace dev eth0 root taprio \
  num_tc 2 map 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \
  queues 1@0 1@1 \
  base-time $BASE \
  sched-entry S 0x1 500000 \
  sched-entry S 0x2 500000 \
  flags 0x0
```

2) TXTIME-assist 模式（flags bit 0 = 0x1）。需要应用使用 SO_TXTIME：

```bash
tc qdisc replace dev eth0 root taprio \
  num_tc 2 map 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \
  queues 1@0 1@1 \
  base-time 0 \
  sched-entry S 0x1 1000000 \
  sched-entry S 0x2 1000000 \
  flags 0x1
```

3) Full offload 模式（flags bit 1 = 0x2）。仅在网卡驱动支持 TAPRIO offload 时有效：

```bash
tc qdisc replace dev eth0 root taprio \
  num_tc 2 map 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \
  queues 1@0 1@1 \
  base-time 0 \
  sched-entry S 0x1 1000000 \
  sched-entry S 0x2 1000000 \
  flags 0x2
```

## 非常小的 interval 是否正常？

- 在纯软件模式下，亚微秒或几百纳秒的 interval 通常不正常。
- 极小 interval 更适合硬件卸载或具备精确时间基的场景。
- 对通用 CPU 的软件调度而言，过小 interval 可能触发计时器“追赶风暴”，形成 DoS 风险。

## 真实场景中为何需要很小 interval？

- 硬件卸载 NIC 可能需要更细粒度的门控窗口，与 PHY/MAC 时间域对齐。
- 纯软件模式下，实际可行的 interval 往往更大，以匹配系统时延和计时器分辨率。

## advance_sched 是通用定时器吗？谁会使用它？

- `advance_sched()` 是 sch_taprio.c 内部的 hrtimer 回调。
- 它不是通用内核接口，其他子系统不会调用它。
- 仅用于 TAPRIO 软件模式的门控推进与队列调度触发。

## 这里的 RCU 是什么？

- RCU（Read-Copy-Update）是一种内核同步机制，允许读路径无锁并发，更新在后台完成。
- 内核需要 CPU 周期性进入 quiescent states，才能完成 RCU grace period。
- 如果定时器进入“追赶风暴”，CPU 被长期占用，就会延迟 quiescent states，RCU 因此报告 `rcu_preempt detected stalls`。

## advance_sched 的设计用途

- 作用：推进当前门控条目，更新 end_time/budget，并重新编程下一次 hrtimer 触发时间。
- 常见路径：仅在非 full offload 的软件模式下使用。

## advance_sched 的典型流程

1) 用户通过 `tc qdisc replace ... taprio` 配置调度表。
2) TAPRIO 初始化条目并启动 hrtimer。
3) `advance_sched()` 在每个条目边界触发，切换条目并重新编程下一次触发。
4) TAPRIO 按当前 gate_mask/budget 出队发送。

## 待讨论事项

- 选择更倾向于输入校验（Option 1）还是运行时保护（Option 2），或二者叠加。
- 如果选 Option 1，需要明确软件模式最小 interval（例如 1 us）及对用户的说明。
- 如果选 Option 2，需要确认重同步逻辑不改变合法调度的语义，同时能避免定时器风暴。
